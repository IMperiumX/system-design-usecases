"""
Django models for the Real-time Gaming Leaderboard system.

System Design Concepts:
    - [[polyglot-persistence]]: PostgreSQL for durable user data, Redis for leaderboard
    - [[audit-logging]]: Game model tracks all matches for recovery and analytics
    - [[time-series-data]]: Games partitionable by month for cold storage
"""

from django.db import models
import uuid


class User(models.Model):
    """
    User profile model.

    System Design Concept:
        Stores player information separate from leaderboard rankings.
        In production, this would be managed by a dedicated auth service
        (e.g., Auth0, Firebase Auth).

    Simplifications:
        - No password/auth fields (assumed to be handled elsewhere)
        - Simple avatar URL instead of file upload

    At Scale:
        - Replicate across multiple regions for low latency
        - Cache frequently accessed profiles in Redis (especially top 10)
        - Use CDN for avatar images
    """

    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False,
        help_text="Unique user identifier (UUID v4)",
    )

    username = models.CharField(
        max_length=50,
        unique=True,
        db_index=True,
        help_text="Unique username for login",
    )

    display_name = models.CharField(
        max_length=100,
        help_text="Display name shown on leaderboard",
    )

    avatar_url = models.URLField(
        blank=True,
        help_text="CDN URL for user avatar image",
    )

    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="Account creation timestamp",
    )

    class Meta:
        db_table = "users"
        ordering = ["username"]
        verbose_name = "User"
        verbose_name_plural = "Users"

    def __str__(self):
        return f"{self.display_name} (@{self.username})"

    def __repr__(self):
        return f"<User id={self.id} username={self.username}>"


class Game(models.Model):
    """
    Audit log for all game matches.

    System Design Concept:
        - Enables [[leaderboard-recovery]] from persistent storage
        - Supports [[event-sourcing]] pattern for analytics
        - [[write-heavy-workload]]: 5M DAU Ã— 10 games/day = 50M writes/day

    Simulates:
        Time-series database like InfluxDB or Cassandra

    Simplifications:
        - Stores only wins (not losses or draws)
        - No opponent information

    At Scale:
        - Partition by month (leaderboard_month field)
        - Archive old months to S3/Glacier after 90 days
        - Use Cassandra or DynamoDB for write scalability
        - Add composite index on (user, leaderboard_month) for player history
    """

    id = models.BigAutoField(
        primary_key=True,
        help_text="Auto-incrementing game record ID",
    )

    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name="games",
        help_text="Player who won this match",
    )

    score_earned = models.IntegerField(
        default=1,
        help_text="Points earned from this match (default: 1 per win)",
    )

    match_id = models.UUIDField(
        help_text="Reference to game service's match record",
    )

    played_at = models.DateTimeField(
        auto_now_add=True,
        db_index=True,
        help_text="When the match was completed",
    )

    leaderboard_month = models.CharField(
        max_length=7,
        db_index=True,
        help_text="Leaderboard month in YYYY-MM format (e.g., '2025-01')",
    )

    class Meta:
        db_table = "games"
        ordering = ["-played_at"]
        indexes = [
            models.Index(fields=["user", "-played_at"], name="idx_user_played"),
            models.Index(fields=["leaderboard_month"], name="idx_month"),
            models.Index(
                fields=["leaderboard_month", "-played_at"], name="idx_month_played"
            ),
        ]
        verbose_name = "Game"
        verbose_name_plural = "Games"

    def __str__(self):
        return f"{self.user.username} scored {self.score_earned} on {self.played_at.strftime('%Y-%m-%d %H:%M')}"

    def __repr__(self):
        return f"<Game id={self.id} user={self.user_id} month={self.leaderboard_month}>"


class LeaderboardSnapshot(models.Model):
    """
    Monthly leaderboard archives.

    System Design Concept:
        - [[archival-storage]]: Stores final rankings when month ends
        - [[batch-processing]]: Generated by cron job on 1st of each month
        - Enables historical queries without keeping Redis data forever

    Simulates:
        Cold storage (S3 + Athena for querying)

    Simplifications:
        - Stores in same PostgreSQL DB (would use separate storage in production)

    At Scale:
        - Move to columnar storage (Parquet on S3)
        - Use AWS Athena or BigQuery for historical analytics
        - Partition by year and month for efficient queries
    """

    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name="leaderboard_snapshots",
        help_text="User who achieved this rank",
    )

    month = models.CharField(
        max_length=7,
        db_index=True,
        help_text="Leaderboard month in YYYY-MM format",
    )

    final_score = models.IntegerField(
        help_text="User's total score at end of month",
    )

    final_rank = models.IntegerField(
        help_text="User's rank at end of month (1-indexed)",
    )

    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="When this snapshot was created",
    )

    class Meta:
        db_table = "leaderboard_snapshots"
        unique_together = [["user", "month"]]
        ordering = ["month", "final_rank"]
        indexes = [
            models.Index(fields=["month", "final_rank"], name="idx_month_rank"),
        ]
        verbose_name = "Leaderboard Snapshot"
        verbose_name_plural = "Leaderboard Snapshots"

    def __str__(self):
        return f"{self.user.username} - Rank #{self.final_rank} ({self.month})"

    def __repr__(self):
        return f"<LeaderboardSnapshot user={self.user_id} month={self.month} rank={self.final_rank}>"
